var _   = require( 'lodash' ),
    md  = require( './markdown' );

/**
 * More than meets the eye!
 * Takes JSDOC AST and outputs Markdown
 * @param {object[]} blocks Array of comment/code objects generated by Doctrine and Esprima.
 * @constructor
 * @private
 */
function Transformer( blocks ) {
  this.blocks = blocks;

  this.classes = { };
  this.run( );
}

Transformer.prototype.run = function( ) {
  _.each( this.blocks, this.runOne, this );
};

/**
 * Generates Markdown for a single comment/code block.
 * @param {object} block
 * @param {object} block.comment Doctrine AST
 * @param {object} block.code Esprima AST
 */
Transformer.prototype.runOne = function( block ) {
  if( this.isConstructor( block ) )
    console.info( this.constructor( block ) );
  else if( this.isMethod( block ) )
    console.info( this.method( block ) );
  else if( this.isVariable( block ) ) {
    this.variable( block );
  }
};

Transformer.prototype.constructor = function( block ) {
 return  md.toH2( this.getSignature( block ) ) +
         md.newLine( ) +
         md.newLine( ) +
         this.getDescription( block ) +
         md.newLine( ) +
         this.params( block );
};

Transformer.prototype.method = function( block ) {
  return md.toH3( this.getSignature( block ) ) +
         md.newLine( ) +
         md.newLine( ) +
         this.getDescription( block ) +
         md.newLine( ) +
         this.params( block );
};

Transformer.prototype.params = function( block ) {
  var params = _.filter( block.comment.tags, { title: 'param' } ),
      item;

  return _.map( params, function( param ) {
    item = md.toUnorderedItem( md.toInlineCode( param.name ) );
    if( param.description )
      item += ' - ' + param.description;
    return item;
  }, this ).join( md.newLine( ) );
};

Transformer.prototype.variable = function( block ) {
};

//TODO block should just be a class and these should be methods..
//TODO perhaps a way to make clearer between code/comment methods
//It's not very intitutive dealing with methods like params...
Transformer.prototype.isPublic = function( block ) {
  return !!_.find( block.comment.tags, { title: 'public' } );
};

Transformer.prototype.isPrivate = function( block ) {
  return !!_.find( block.comment.tags, { title: 'private' } );
};

Transformer.prototype.isConstructor = function( block ) {
  return !!_.find( block.comment.tags, { title: 'constructor' } );
};

Transformer.prototype.isMethod = function( block ) {
  return ( block.code.type === 'FunctionDeclaration' ||
          ( block.code.type === 'ExpressionStatement' &&
            block.code.expression.right.type === 'FunctionExpression' ) )
};

Transformer.prototype.isVariable = function( block ) {
  return false;
};

Transformer.prototype.getDescription = function( block ) {
  return block.comment.description;
};

Transformer.prototype.getSignature = function( block ) {
  var name = this.getFunctionName( block ),
      params = this.getParamNames( block );

  return name + '(' + params.join(', ' ) + ')';
};

Transformer.prototype.getParams = function( block ) {
  var params = block.code.params;
  if( block.code.type === 'ExpressionStatement' &&
      block.code.expression.right.type === 'FunctionExpression' )
    params = block.code.expression.right.params;
  return params;
};

Transformer.prototype.getFunctionName = function( block ) {
  if( block.code.type === 'FunctionDeclaration' )
    return block.code.id.name;

  if( block.code.type === 'ExpressionStatement' &&
        block.code.expression.right.type === 'FunctionExpression' )
    return block.code.expression.left.property.name;
};

Transformer.prototype.getParamNames = function( block ) {
  return _.pluck( this.getParams( block ), 'name' );
};

module.exports = Transformer;
